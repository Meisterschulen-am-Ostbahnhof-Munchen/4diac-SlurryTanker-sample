from argparse import ArgumentParser
from os import path

parser = ArgumentParser()
parser.add_argument("-o", "--oldfile", dest="old_file", required=True)
parser.add_argument("-n", "--newfile", dest="new_file", required=True)
args = parser.parse_args()
print(f"{args.old_file}, {args.new_file}")


def strings_to_dict(input_strings):
    temp_dict = {}
    for input_string in input_strings:
        # Find the index of the first non-whitespace character after the first word
        first_space_index = input_string.find(' ')
        if first_space_index == -1:
            temp_dict[input_string.strip()] = ''
            continue
        next_char_index = first_space_index + 1
        while next_char_index < len(input_string) and input_string[next_char_index].isspace():
            next_char_index += 1

        # Split the string based on the next non-whitespace character
        key = input_string[:next_char_index].strip()
        value = input_string[next_char_index:].strip()
        if value == '':
            value = None
        temp_dict[key] = value

    return temp_dict


def get_value_type(get: str) -> str:
    if get.startswith("\"") or get.startswith("\'"):
        return "STRING "
    else:
        return "UINT   "


def align_letters(to_aligned) -> list:
    # Calculate the maximum length of the keys
    max_key_length = max(len(key) for key in to_aligned.keys())
    temp_list = []

    # Print out the key-value pairs with the appropriate spacing
    for key, value in to_aligned.items():
        spacing = ' ' * (max_key_length - len(key) + 1)
        temp_list.append(
            f"{key}{spacing}: {get_value_type(value)} := {value.ljust(max_key_length - len(key) + len(value.split()[0]) + 1)}".strip() + ";"
        )
    return temp_list


def create_new_file(new_file, old_file):
    file_old = open(old_file, "r")
    lines = file_old.readlines()

    count = 0
    lines_list = []
    for line in lines:
        count += 1
        line = line.replace("#define ", "")
        line = line.replace('"', "'")
        if not line.__contains__("//"):
            lines_list.append(line)

    my_dict = strings_to_dict(lines_list)

    file_new = open(f"{new_file.split('/')[-1]}.globalconsts", "x")
    hard_lines = ["// Generated by PoolSkript.py \n", "// Do not change!\n",
                  "VAR_GLOBAL CONSTANT\n"]

    file_new.writelines(hard_lines)
    for i in range(len(my_dict)):
        file_new.writelines(f"    {align_letters(my_dict)[i]}\n")
        if i == len(my_dict) - 1:
            file_new.writelines("END_VAR")
    align_letters(my_dict)


def start():
    old_filepath = args.old_file
    new_filepath = args.new_file.split("/")[-1]

    print("LÃ¤dt...")
    create_new_file(new_file=new_filepath, old_file=old_filepath)
    print("Done.")


start()
